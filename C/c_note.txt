一、格式化输入输出
  1) printf
    用来显示格式串(包含普通字符串和转换说明)的内容。
    *转换说明*
      以字符%开头，用来表示打印过程中填充了值的占位符。跟随在%后面的信息指定了把数值从内部(二进制)形式转换成打印(字符)形式的方法，这也是“转换说明”术语的由来。
      >比较通用的情况下，转换说明可以有%m.pX格式或%-m.pX格式
        最小字段宽度：m指定了要显示的最小字符数量。如果要打印的数值比m个字符少，那么值在输出时是右对齐的(换句话说，在数值前放置额外的空格)。例如%4d显示15时将以··15显示(其中·表示空格)。在显示浮点数时，m也表示整个浮点数所占的字符串，如11.12的长度为5。

        精度：p的含义依赖于转换说明符X。X表明在显示数值需要对其进行哪种转换。对数字来说常用的转换说明符有：
          d ——  表示十进制形式的整数。p说明可以显示的数字的最少个数(个数不够将在数前加上额外的0)；如果忽略p，默认p=1
          e ——  表示指数(科学计数法)形式的浮点数。p说明小数点后应该出现的数值个数(默认为6)。如果p为0，则不显示小数点
          f ——  表示“定点十进制”形式的浮点数，没有指数。p含义与在e中一样
          g ——  自动选择 e 或 f 形式，形式的选择根据数的大小决定。p说明可以显示的有效数字(没有小数点后的数字)的最大数量。此外，与转换说明f不同，g的转换将不显示尾随0(f小数点后会用0填充)，并且如果显示的数值没有小数点后的数值，g不会显示小数点
          u ——  十进制无符号整数
          o ——  八进制无符号整数
          x ——  十六进制整数
          h ——  读写短整型数时，在d o u x前面加上字母h。例：short int s;scanf("%hd",&s);
          l ——  读写长整型数时，在d o u x前面加上字母l。例：long int n;scanf("%ld",&n);
          读写浮点数：读取double时，在e f g前放置字符l,读写long double时，在e f g前加字符L
          c ——  表示一个字符，在scanf函数中，在读入字符前，scanf函数不会跳过空白字符。
    *转义序列*
      常用转义序列：
        \"
        \b    回退符，将光标回退一个位置(可以用来覆盖控制台上的输出内容)。
        \t
        \n
        \\

  2) scanf
    像printf函数一样，scanf函数也根据特定的格式读取输入。scanf函数的格式串也可以包含普通字符串和转换说明两部分。
    例： scanf("%d%d%f",&i,&j,&k);

    *scanf函数的工作方式*
      scanf函数本质上是一种“模式匹配”函数，也就是试图把输入的字符组与转换说明匹配成组。
      调用时，scanf函数从左边开始处理字符串中的信息。对于格式串中的每一个转换说明，scanf函数努力从输入的数据中定位适当类型的项，并且跳过必要的空格。然后，scanf函数读入数据项，并且在遇到不可能属于此项的字符时停止。如果读入数据项成功，那么scanf函数会继续处理格式串的剩余部分。如果某项不能成功读入，那么scanf函数将不再查看格式串剩余(或余下的输入数据)而直接返回。
      注意：
      1.在寻找数据项的起始位置时，scanf函数会忽略空白字符(空格、横向和纵向制表符、换行符和换页符)，这样可以把数值放在单独一行或分散在几行内输入
      2.当scanf函数遇到的字符不是当前项的内容时，会把此字符“放回原处”，在扫描下一个输入项或在下一次调用scanf函数时，才会读入此字符。

    *格式串中的普通字符*
      空白字符：当在格式串中遇到一个或多个连续的空白字符时，scanf函数从输入中重复读空白字符直到遇到一个非空白字符(会把该字符“放回原处”)为止。

      其他字符：当在格式串中遇到一个非空白字符时，scanf函数将把它与下一个输入字符进行比较，如果匹配，那么scanf函数会放弃输入字符继续处理格式串。如果不匹配，那么scanf函数会把不匹配的字符放回输入中，然后异常退出，不进行进一步处理格式串。

二、表达式
  1）左值
    左值表示存储在计算机内存中的对象，而不是常量或者计算结果。赋值运算符要求左边的操作数是左值。

  2）赋值运算符 
    在C中，赋值是运算符。赋值操作会产生结果，如同两个数相加产生结果一样。赋值表达式i = y的值就是赋值运算后i的值。

  3）复合赋值运算符
    C中有九个复合赋值运算符，包括
    += 、 -= 、 *= 、 /= 、 %=
    他们都是右结合的，所以i += j += k => i += (j += k)

  4) 运算符优先级
    优先级               类型名称                符号                结合性
      1                 (后缀)自增、自减          ++、--              左结合

      2                 (前缀)自增、自减          ++、--              右结合

      3                 乘法类                   * / %              左结合
      
      4                 加法类                   + -                左结合

      5                 赋值                    = *= /= %= += -=    右结合

三、控制语句
  1)逻辑表达式
    C语言中没有逻辑类型或布尔类型，逻辑表达式的值为1(真)或0(假)。所以a<b<c在C中是合法的，但结果可能不是你想要的。

  2）关系运算符 
    与Java一样，有
      > 
      < 
      >= 
      <= 
    判定运算符有
      != 
      ==
    关系运算符与判定运算符优先级低于算数运算符，且都是左结合的。

  3）逻辑运算符
    逻辑运算符将非0数当成值来处理，将0值当成假值处理。
      ！  优先级与一元正号、负号(+、-)相同，且是右结合
      ||  短路或，左结合
      &&  短路与，左结合
      ||和&&的优先级低于关系运算符和判定运算符

  4）if语句
    和java一样
    **在C中，对{多条语句；}的定义是将多条语句合并成一条语句，{}中的语句就组成复合语句**

  5）条件表达式 
    表达式1？表达式2：表达式3
    优先级低于除了赋值运算符外的所有运算符

  6）switch语句
    switch(整型表达式){
      case 常量表达式 : statements;break;
      ...
      ...
      ...
      default : statements;break;

    }

    1.没有case能够匹配时：将会匹配default
    2.break的作用：在case匹配到值时，执行该case的最后一条语句后，控制程序“向下跳转”到下一种情况的第一条语句上，而忽略下一种情况的情况标号。
    3.每个情况标号(【case 常量表达式：】即为情况标号)后可以跟任意数量的语句，而不需要大括号。

四、循环
  1）while、do while与java中一样

  2）for(表达式1;表达式2;表达式3)，可以使用逗号(,)分隔多个表达式，逗号分隔符是左结合的，当一个表达式中使用了逗号分隔多个表达式，左边表达式的值会被丢弃，再计算右边的表达式的值返回，以此类推。

  3）break、continue、goto
    [goto语句]goto 标识符;
    [标号语句]标识符：语句

五、基本类型
  1）整型
    分为两大类：有符号、无符号
    1.整数通常以16位或32位方式存储，在有符号数中，数为正数或0，那么最左边的位(符号位)为0，如果是负数，符号位则为1。所以最大的16位整数是0111111111111111(值为32767，即2^15-1),最大32位整数是2^31-1。
    2.默认情况下，C语言中的整型变量都是有符号的。使用unsigned将变量声明为无符号类型。

    长整型、短整型、整型可以产生的类型（16位机上的整型范围）：
    类型                    最小值               最大值
    short int               -32768(-2^15)       32767(2^15-1)
    int                     -32768              32767
    long int                -2147483648(-2^31)  2147483647(-2^31)
    unsigned short int      0                   65535(2^16-1)
    unsigned int            0                   65535
    unsigned long int       0                   4294967295(2^32-1)

    C语言允许省略单词int来缩写整型的名字，例如long int可以省略为long。其次，说明符的顺序没有要求，所以unsigned short int和short unsigned int是一样的。

    *整型常量*：
      C语言允许用十进制、八进制、十六进制书写整型常量，用什么方式书写不会对数的实际存储方式造成影响。(整数都是以二进制形式存储的)
      十进制：包含数值0~9，一定不能以0开头
      八进制：必须要以0开头
      十六进制：必须以0x或0X开头，十六进制常量中的字符既可以是大写也可以是小写的

      当程序中出现整型常量时，如果它属于int类型的取值范围，那么编译器会把此常量作为普通整数来处理，否则作为长整数来处理。如果需要编译器把常量作为长整数处理，只需在常量后加上字母L(或小写)：
        15L 0377L  0X7fffL
      为了指明是无符号常量，可以在后面加上字母U(或小写)：
        15U 743U  0x7fffU
      特别的，U和L可以一起使用，顺序无关。

  2）浮点型
    float : 单精度浮点数
    double : 双精度浮点数
    long double : 扩展双精度浮点数

    *浮点常量*
      有多种书写方式，例如下面的常量全都表示数57.0
      57.0  57. 57.0e0  57E0  5.7e+1  .57e2  570.e-1

      默认情况下，浮点常量都以双精度的形式存储。如需要以float或long double格式存储，可以再常量的末尾处加上字符F(或f)表示单精度，L(或l)表示扩展双精度。

    *读/写浮点数*

  3）字符型
    1.C会按照小整数的方式处理字符。当计算中出现字符时，C只是使用它对应的整数值。
    2.C标准没有说明普通char型数据是有符号还是无符号型，所以不要假设char类型默认类型。

    *读写字符*
      转换说明%c允许scanf函数和printf函数对单独一个字符进行读写操作。
      char ch;
      scanf("%c",&ch);
      printf("%c",ch);
      在读入字符前，scanf不会跳过空白字符。为了强制scanf函数在读入字符前跳过空白字符，可在格式转换说明%c前加上一个空格：scanf(" %c",&ch);

      getchar() : 从输入缓冲区中读取一个字符并返回，
      putchar(char ch) : 打印一个字符。

      getchar和putchar的速度比scanf和printf快

  4）sizeof运算符
    sizeof(类型名)，返回一个无符号整数。这个整数表示用来存储该类型的值所需要的字节数。sizeof也可以作用在变量、常量或表达式上，来计算变量或常量的类型所占存储空间。
    **由于sizeof是一个一元运算符，所以可以省略括号。例：printf("%d",sizeof 1);

  5)类型转换 
    在执行算数运算时，通常要求操作数有相同的大小和类型，C语言允许在表达式中混合使用基本数据类型，所以C语言编译器可能需要生成一些指令将某些操作数转换成不同类型。编译器可以自动处理的转换叫做隐式转换，C还允许通过强制运算符执行显示转换。
    隐式转换：
      ●算数表达式或逻辑表达式中操作数的类型不同(C执行所谓的常用算数转换)
      ●赋值运算符右侧表达式的类型和左侧变量类型不匹配时
      ●函数调用中使用的参数类型和对应的参数类型不匹配时
      ●return语句中表达式的类型和函数返回值的类型不匹配时

      整型提升：操作数两侧的数值类型不一样时，将操作数转换成可以安全的适用于两个数值的“最狭小的”数据类型，通常可以将相对较狭小类型的操作数转换为另一个操作数的类型来实现。整型提升它把字符或短整型转换成int类型(某种情况下是unsigned int类型)。

      I:常用算数转换：
        1.任一操作数的类型是浮点型的情况，按照类型较狭小的操作数进行提升：
                            long double
                                 ↑
                               double
                                 ↑
                               float

        2.两个操作数的类型都不是浮点型的情况。首先对两个操作数进行整型提升(保证没有一个操作数时字符型或短整型)。然后按照下图对操作数的类型进行提升：
                            unsigned long int
                                 ↑
                              long int
                                 ↑
                            unsigned int
                                 ↑
                                int
        有种特殊情况，只有在long int类型和unsigned int类型长度相同时会发生，这类情况下，如果一个操作数的类型是long int，而另一个的类型是unsigned int，那么两个操作数都会转换成unsigned long int.

      II:赋值中的转换

    显式转换(强制类型转换)：
      执行运算时有时候C的隐式转换会造成精度丢失的问题，可以在发生隐式转换前使用类型符号进行强制类型转换。如：
      int x = 10,y = 3;
      float f = (float)x/y;
      分析：如果不进行强制类型转换，两个整型x/y的结果为整型，结果为3，赋值给float型，发生隐式转换，结果为3.0。
      将x强制转换成float后，x/y运算会将y提升为float型，x/y的结果为float类型的3.333333，再将结果赋值给f。

    PS:C把类型名称视为一元运算符。一元运算符的优先级高于二元运算符

  6）类型定义
    typedef int Bool;(将Bool定义成int类型,结尾加上分号)
    采用typedef定义Bool会导致编译器在它所识别的类型名列表中加入Bool。Bool类型可以和内置的类型名一样用于变量声明、强制类型转换等使用基本类型的地方。

    还有另一种定义类型的方式
    #define BOOL int
    这种方式在编译时编译器将程序中有BOOL的地方替换成int

六、数组
  1）初始化
    int a[10] = {1,2,3,4,5,6,7,8,9,10};

    如果初始化比数组短，那么剩余元素初始化为0：
    int a[10] = {1,2,3,4,5,6};/*array is {1,2,3,4,5,6,0,0,0,0}*/

    可以利用这一特性给数组全部元素初始化为0：
    int a[10] = {0};/*array is {0,0,0,0,0,0,0,0,0,0}*/

    如果显示一个初始化式，那么可以忽略掉数组长度：
    int a[] = {1,2,3,4,5,6,7,8,9,10};//array length is 10

    初始化完全为空是非法的：int a[] = {};/*WRONG*/

    **数组与sizeof**
      1.sizeof可以确定数组的大小(字节数)，还可以使用sizeof计算数组元素的大小。利用数组大小除以元素大小可以得到数组的长度：
      int a[10] = {1,2,3};
      int length = sizeof(a)/sizeof(a[0]);

      可以使用宏计算数组长度：
      #define SIZE sizeof(a)/sizeof(a[0]);
      int length = SIZE;

  2)多维数组
    int m[5][9];
    二维数组虽然以表格形式显示，但实际上在计算机的内存中是按照顺序存储数组的，也就是说，先存第0行，接着第1行，如此下去：
            row0             row1             row2                    row5
     _______丨______ _______丨______  _______丨______
    丨             丨丨             丨丨             丨 ............
    口口口口口口口口口口口口口口口口口口 口口口口口口口口口                
  *多维数组的初始化*
  int m[5][9] = {
    {1,2,3,4,5,6,7,8,9},
    {1,2,3,4,5,6,7,8,9},
    {1,2,3,4,5,6,7,8,9},
    {1,2,3,4,5,6,7,8,9},
    {1,2,3,4,5,6,7,8,9}
  };

  如果初始化式不达到足以填满整个多维数组，那么数组剩余的元素赋值为0：
  int m[5][9] = {
    {1,2,3,4,5,6,7,8,9},
    {1,2,3,4,5,6,7,8,9}
  };/*改初始化式只填满了数组的前两行，后两行将赋值为0*/

  如果内层的列表不大到足以填满数组的一行，那么把此行剩余的元素初始化为0：
  int m[5][9] = {
    {1,2,3,4,5,6,7},
    {1,2,3,4,5,6,7,8,9},
    {1,2,3,4,5},
    {1,2,3,4},
    {1,2,3,45,6,7,8,9}
  };

  还可以忽略掉内层的大括号：
  int m[5][9] = {
     1,2,3,4,5,6,7,8,9,
     1,2,3,4,5,6,7,8,9,
     1,2,3,4,5,6,7,8,9,
     1,2,3,4,5,6,7,8,9,
     1,2,3,4,5,6,7,8,9
  };/*使用此方法一旦编译器发现足够的数填满一行，它就开始填充下一行，不能填充完的赋值为0*/
  
  【Tips】:
  1）初始化一个数组后，可以修改数组中的元素的值，但是无法给数组重新赋值。
    int a[3] = {0};
    a = {1,2,3};//WRONG
    数组名不是左值

七、函数
  （void用作占位符，意味着“没有任何东西”）
  1）函数定义
    返回类型 函数名 (形式参数)
    {
      声明;
      语句;
    }
    ● 函数无法返回数组，但是没有其他关于返回值的限制
    ● 如果忽略返回类型，那么会假定函数返回类型是int型
    ● 指定返回类型为void说明函数没有返回值
    ● 如果没有形式参数，圆括号内应出现void 例：void dosomething(void){...}
    ● 为了清楚表示丢弃函数返回值，可以在函数调用前加上(void)。例(void) printf("hello world");

  2）函数声明
    当调用函数时，编译器可能没有关于被调用函数的信息(函数形参、形参类型、返回值类型等)，但是编译器没有产生错误信息，而是对函数给出几个假设，可能由于假设是错误的，所以程序无法工作。为了避免定义前调用这类问题发生，可以安排每个函数定义在调用前进行(缺点是可能导致程序难于阅读，并且这类安排并不总是存在)。
    C语言提供了一种更好的解决方式：在调用前声明每个函数。形式：
      返回类型  函数名  (形式参数);
    函数声明也叫函数原型。函数原型不需要说明形式参数的名字，只要显示他们的类型就可以了：
      float average(float,float);

  3）实际参数转换
    *编译器在调用前遇到原型*：像赋值一样，每个实际参数的值被隐式转换成形式参数的类型。
    *编译器在调用前没有遇到原型*：编译器执行默认的实际参数提升，(1)float型的实际参数转换成double，(2)执行整数的提升(即把char型和short型的实际参数转换成int)。
    思考：
    int main(){
      int i;
      scanf("%d",&i);
      printf("The answer if %g\n",square(i));/** WRONG **/
      return 0;
    }

    double square(double x){
      return x * x;
    }
    调用square函数时，编译器没有遇到原型，所以编译器在变量i上执行了没有效果的默认的实际参数提升。由于square函数期望有double类型的实际参数，却获得了int型值，所以程序无法正确运行。可以通过将i强制转换为double类型解决这个问题：
    square((double)i);
    这个问题使我们【始终在调用函数前声明函数】变得更加必要。

    **数组作为参数传递：
      不需要声明数组的长度。在把数组传递给函数时，是把指向数组第一个元素的指针传递给了函数。其次，下标的工作方式是：比如有a[i] = 0;编译器计算a[i]的地址时，是把i乘以每个元素的大小，并把乘积结果加上数组a表示的地址(传递给函数的指针)。这个过程没有依赖数组a的长度，说明了为什么可以在定义函数时忽略数组长度。

    **多维数组作为参数传递：
      C是按照主序存储数组的，即首先存储第0行的元素，然后第一行，以此类推。假设a是二维数组的形式参数，并有语句a[i][j]=0;编译器产生指令执行如下：(1)把i乘以数组中每行的大小; (2)把乘积的结果加上数组a表示的地址; (3)把j乘以数组a中每个元素的大小;(4)把乘积的结果加上第二步计算出的地址。为了产生这些指令，编译器必须知道数组a中每一行的大小，行的大小由列数决定。
      所以：必须声明数组拥有的列的数量。

  4）return语句
    同Java

    exit函数： 属于stdlib.h，传递给exit()函数的值与main函数的返回值意义一致，两者都说明程序终止时的状态。为了说明正常终止，传递0。

八、程序结构
  1）在局部变量中放置static可以使变量从自动存储期限(函数调用时自动分配变量的存储单元，函数返回时收回分配)变为静态存储期限(拥有永久的存储单元)。局部静态变量始终有程序块作用于，它对于其他函数而言是不可见的。它会为将来的同一个函数调用保留这些数据。

  2）外部变量(全局变量)
  声明在任何函数体外，性质：
    1.静态存储期限：如同声明为static的局部变量一样，存储在外部变量中的值将永久保留下来。
    2.文件作用域：从变量声明的点开始一直到闭合文件的末尾。结果是，跟随在外部变量声明后的所有函数都可以访问它。

九、指针
  int *p;
  声明一个指针，p的值为一个int型变量的地址，*p指向这个int型变量实际内存区域。
  int i = 0;
  p = &i;
  将i的地址赋值给p,此时p的值为变量i存储数据的地址，*p代表i存储数据的那块内存地址。
  *p = 10;
  将*p指向的内存存储的数据改为10，此时i == 10;
  0）取地址运算符(&) 与 间接寻址运算符(*)
    & : 如果x是变量，那么&x就是x在内存中的地址
    * : 一旦指针变量指向了对象，就可以使用*（间接寻址）运算符访问存储在对象中的内容。
    所以：
    如果p是一个指针，并且指向一个对象，则p 与 &(*p) 等价


  1）const
    ● 用const修饰指针型形参，表示不会修改指针指向的内存区域。
      void f(const int *p){
        *p = 0;/*WRONG*/
      }
      还能用const修饰变量，表示无法修改变量
      void f(const int * const p){
        p = 0;/*WRONG*/
      }
      还可以同时修饰
      void f(const int * const p);
  2）指针的运算(指针有且只有三种算术运算符)
    假设有声明：

    int a[10],*p;

    1.指针加上整数
      指针p加上整数产生指向特定元素的指针，这个特定元素是p原先指向的元素后的j个位置。
      p = &a[0];/*使p指向a[0],此时可通过p访问数组第一个元素*/
      p = p +3;/*此时p==&a[0 + 3]*/

    2.指针减整数
      如果p指向数组元素a[i],那么p-j指向a[i-j]

    3.指针相减
      当两个指针相减时，结果为指针之间的距离(用来计算数组中元素的个数)。因此如果p指向a[i]且q指向a[j],那么p-q就等于i-j。

    **只有在p指向数组元素时，指针p上的算数运算才会获得有意义的结果。

    **指针比较
      可以使用关系运算符<、<=、>、>=和判等运算符(==、！=)进行比较，比较结果取决于数组中两个元素的相对位置。
      (按所在位置索引大小判断)

    **数组名作为指针
      可以将数组名当成指针，这个指针指向数组的第一个元素。思考：
      int a[10];
      *(a + 1) = 11;/*将数组第二个元素赋值为11*/

    **指针与多维数组
      1）处理多维数组的元素
        我们已经知道了多维数组的存储格式，如果使指针p指向二维数组中的第一个元素(第0行0列的元素)，就可以通过重复自增p的方式遍历多维数组。
      2）处理多维数组的某一行
        假设a为二维数组,处理二维数组的第i行
        int a [ROWS][COLUMNS];
        int *p = a[i][0];/*等价于p=a[i]*/
        for(;p < a[i] + COLUMNS;p++)/*遍历二维数组第i行*/
      3）用多维数组名作为指针
        int a[],b[10][10];
        可以使用a作为指针指向元素a[0],但不是说b是指向b[0][0]的指针，而是说b是指向b[0]的指针(指向指针的指针)。从C语言来看待它是很有意义的，C语言认为b不是二维数组而是作为一维数组，而这个一维数组的每一个元素又是一维数组。
        按类型来看，a可以用作是int *型的指针，而b用作指针时这是具有int **型的指针(指向整数指针的指针)。

十、字符串
  1）存储字符串字面量
    从本质上而言，C把字符串字面量作为字符数组来处理。当编译器在程序中遇到长度为n的字符串字面量时，它会为字符串字面量分配长度为n+1的内存空间。内存空间将用来存储字符串字面量中的字符，以及一个额外的字符——空字符，空字符用来标志字符串的末尾。空字符时ASCII字符集中真正的第一个字符，因此它用'\0'表示。

    由字符串字面量的性质，可有下面操作：
    char *p;
    p = "abc";//使p指向"abc"
    char ch;//
    ch = "abc"[1];//将'b'赋值给ch
    ch = "abc"[3];//将'\0'赋值给ch
  
  2）字符串变量
    一些编程语言为声明字符串变量提供了特殊了string类型，而C采取了不同的策略：只要保证字符串是以空字符('\0')结尾的，任何一维的字符数组都可以用来存储字符串(C函数库中的函数假设字符串都是以空字符结束的)。
    1.初始化字符串变量
      char date1[8] == "June 14";
      编译器将把字符串"June 14"中的字符复制到数组date1中，然后追加一个空字符从而使date1可以作为字符串使用。
      char date2[9] == "june 14";
      如果初始化太短以致于不能填满字符串变量时，编译器会添加空字符填满数组。
      char d[3] = "123";
      此时编译器把初始化式中的字符简单的赋值到d中，不会追加空字符。
      char d[3] = "1234";
      此时编译器会警告数组越界。

      char date[] = "June 14";
      使用这种方式是可以的，编译器将为date分配8个字符的空间以刚好可以追加一个空字符。

  3）字符数组与字符指针
    比较：
    char date [] = "June 14";
    char *date = "June 14";
    因为数组和指针之间的紧密关系，使得两个声明中的date都可以作为字符串。尤其是，任何期望传递字符数组或字符指针的函数都将接受这两种声明的date作为参数。

    然而，上面两种date还是有显著的差异：
    ● 在声明为数组时，就像任意数组元素一样，可以修改存在date中的字符。在声明为指针时，date指向字符串字面量。而字符串字面量是不可以被修改的。
    ● 在声明为数组时，date是数组名。在声明为指针时，date是变量，这个变量可以在程序执行期间指向其他字符串，但是数组名无法重新赋值。

  4）字符串的读/写
    1.写出字符串
      ● printf
        printf("value of str : %s\n","Are we having fun yet?");
        printf函数会诸葛写字符串中的字符直到遇到空字符才停止(如果空字符丢失，printf函数会越过字符的末尾继续读取内存往外写，直到在内存中遇到空字符)。
        【使用%m.ps或%-m.ps转换说明格式化字符串输出，p说明显示字符串中的前p个字符，m说明显示的字符串所占空间，如果字符串小于m个字符，则会在域内右对齐输出，若想左对齐，在m前加上-号】

      ● puts
        puts(str);
        puts只有一个参数，就是要显示的字符串。写完字符串后，puts函数总会添加一个额外的换行符。

    2.读入字符串
      ● scanf
        scanf("%s",str);
        在scanf函数调用中，不需要再str前添加&，因为str是数组名，编译器会自动把它当做指针来处理。调用时，scanf会跳过空白字符，然后读入字符，并且把读入的字符存储到str中，直到遇到空白字符为止。scanf函数使用会在字符串末尾存储一个空字符。

      ● gets
        gets(ch)
        get函数把读入的字符放到数组中，然后存储一个空字符。

      ● gets和scanf的差异
        1.get函数不会在读入字符串之前跳过空白字符(scanf函数会跳过)。
        2.gets函数会持续读入直到找到换行符才停止(scanf函数会在任意空白符处停止)。此外，gets函数会忽略掉换行符，而不会把它存入数组，用空字符替代换行符。
        **3.scanf和gets函数都是不安全的，它们都无法检测何时能填满数组。因此，它们可能越过数组的边界存储字符，这会导致程序异常。
  5）字符串数组
    两种声明方式：
    1.
      char ch [] [8] = {
        "hello",
        "world",
        "xixi"
      }; 
      缺点：浪费空间，编译器会在内存中开辟8 * 3个字节的空间，无论实际字符串总长度是不是24个字节。
    2.
      char * ch[] = {
        "hello",
        "world",
        "xixi"
      }
      声明了一个数组，其中数组的每个元素都是一个指针，指向一个char类型。根据数组与指针的关系，ch也是一个指针，指向数组第一位，所以ch是一个指向指针的指针。
      其中：
      ch == &ch[0] 
      可以这样遍历每个字符串：
      char **p;
      for(p = ch;*p != NULL;p++);
      或者
      for(p = &ch[0];*p != NULL;p++);//NULL是一个空指针，它不指向任何元素
      或者
      for(p = &ch[0];p < ch + 3;p++);
      【记住ch是一个数组很重要，因为ch是数组，所以ch指向ch[0]】

  6）命令行参数
    在运行程序时，会经常需要提供一些信息——文件名或是改变程序行为的参数。为了能够访问这些命令行参数(程序参数)，必须把main函数定义为含有两个参数的函数：
    int main(int n,const * ch[]){}
    可以获取参数数量n,ch是指向命令行参数的指针数组，这些命令行参数以字符串的形式存储。ch[0]指向程序名，从而ch[1]到ch[n-1]则指向余下的命令行参数。
    (ch有一个附加元素，即ch[n],这个元素是一个空指针。)


  Tips:
  1）延续字符串字面量
    I:把第一行用字符\结尾，那么C就允许在下一行延续字符串字面量了。(不只是字符串，字符\还可以用来分隔任何长的符号，包括函数调用，变量等等)，缺点是：字符串字面量必须从下一行的起始位置继续。

    II：C标准化时引入新的方式，当两条或更多条字面量相连时(仅用空白字符分隔)，编译器必须把他们合并成单独一条字符串。例：
      printf("hell" "o wor"
          "ld");