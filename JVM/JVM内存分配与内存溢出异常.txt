一.Java虚拟机所管理的内存包括以下几个运行时的数据区域
	1.程序计数器
		1)作用:
			可以看成是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型中，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器完成。

		2)特点:
			I:线程私有
			II:占用内存较小
			III:如果线程正在执行的是一个Java方法,这个计数器记录的是正在执行的虚拟机字节码指令的地址;如果正在执行的Native方法,这个计数器值则为空(Undefined)
			IV:此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。

	2.Java虚拟机栈
		1)作用:
			虚拟机栈描述的是Java方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧(stack frame)用于存储【局部变量表】、【操作栈】、【动态链接】、【方法出口】等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

		2)特点:
			I:线程私有,生命周期与线程相同
			
			
		3)局部变量表:存放了编译期可知的各种【基本数据类型】、【对象引用】和【returnAddress类型】,其中64位长的long和double类型的	数据会占用2个局部变量空间(slot),其余的数据类型只占一个。

			I:基本数据类型:boolean byte short char int float long double
			II:对象引用:reference类型,它不等同于对象本身,根据不同的虚拟机实现,它可能是一个指向对象起始地址的引用指针,也可能指向一个代表对象的句柄或其他与此对象相关的位置
			III:returnAddress类型:指向了一条字节码指令的地址

		局部变量表所需的内存空间在编译期间完成分配,当进入一个方法时,方法需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小

		4)异常状况:
			StackOverflowError : 线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常
			OutOfMemoryError : 如果虚拟机栈可以动态扩展(当前大部分Java虚拟机都可以动态扩展,Java虚拟机规范中也允许固定长度的虚拟机栈),当扩展无法申请到足够内存时会抛出OutOfMemoryError


	3.本地方法栈
		1)作用:
			与虚拟机栈所发挥的作用是非常相似的,虚拟机栈为虚拟机执行Java方法(字节码)服务,本地方法栈则是为虚拟机使用到的Native方法服务。(虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（例如Hot Spot）直接就把本地方法栈和虚拟机栈合二为一)

		2)特点:

		3)异常状况:
			与虚拟机栈一样,本地方法栈区域也会抛出StackOverFlowError和OutOfMemoryError异常

	4.堆(Heap)
		1)作用
			此内存区域唯一的目的就是存放对象实例,几乎所有的对象实例都在这里分配内存。这一点在虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。(随着一些技术的发展，所有对象都分配在对堆上也渐渐变得不是那么‘绝对’了)


		2)特点
			I:被所有线程共享的一块内存区域
			II:在虚拟机启动时创建
			III:对于大多数应用来说,Java堆是虚拟机所管理的内存中最大的一块
			IV:Java堆可处于物理上不连续的内存空间中,只要逻辑上是连续的即可
			V:大小可扩展(主流虚拟机都是按照可扩展来实现)通过-Xmx和Xms控制

		3)异常状况
			OutOfMemoryError : 如果在对中没有内存完成实例分配,并且堆也无法再扩展时,将会抛出OutOutMemoryError异常 

	5.方法区（Method Area）
		1）作用：
			用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也有一个名称叫做NonHeap(非堆)

		2）特点：
			I:各个线程共享的内存区域
			II:可处于物理上不连续的内存空间
			III:可以选择固定大小或者可扩展
			IV:可以选择不实现垃圾收集
			V:垃圾收集行为在这个区域是比较少出现的,这个区域的内存回收目标主要是针对【常量池的回收】和【对类型的卸载】

		3）异常状况：
			OutOfMemoryError : 当方法区无法满足内存分配需求时,将抛出OutOfMemoryError异常

	6.运行时常量池(Runtime Constant Pool)
		1)作用
			是【方法区的一部分】。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(Constant Pool Table),用于存放编译期生成的各种【字面量】和【符号引用】，这部分内容将在类加载后存放到【方法区的运行时常量池】中。
			一般来说，除了保存Class文件中描述的符号引用外,还会把翻译出来的直接引用也存储在运行时常量池中

		1.1)好处			
			I:常量池的主要好处:为了避免频繁的创建和销毁对象而影响系统性能,其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中
			II:节省内存空间:常量池中所有相同的字符串常量被合并,只占用一个空间
			III:节省运行时间:比较字符串时,==比equals快,对于两个引用变量,只用==判断引用是否相等,也就可以判断实际值是否相等

		2)特点
			I:动态性(并非预置入Class文件中常量池的内容才能进入方法区运行时常量池,运行期间也可能将新的常量放入池中.例:String类的intern()方法)
			II:运行时常量池是方法区的一部分,内存大小自然受到方法区内存的限制

		3)异常状态:
			OutofMemoryError : 当常量池无法在申请到内存时会抛出OutOfMemoryError异常

	7.直接内存
		直接内存并不是虚拟机运行时数据区的一部分,也不是Java虚拟机规范中定义的内存区域,但这部分内存也被频繁使用,而且也可能导致OutOfMemoryError

		JDK1.4中加入了NIO(new input/output)类,引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式,它可以使用Native函数直接分配堆外内存,然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能。

		OutOfMemoryError : 本机直接内存分配不会受到Java堆大小的限制,但是会受到本机总内存的大小以及处理器寻址空间的限制。当配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息,但经常会忽略掉直接内存,使得各个内存区域的总和大于物理内存限制(包括物理上的和操作系统级的限制),从而导致动态扩展时出现OutOfMemoryError异常

	对象访问:
		最简单的访问,也会涉及到Java堆、Java栈、方法区这三个最重要的内存区域之间的关联关系，如：

		Object obj = new Object();

		假如这段代码出现在方法体中,那Object oj 语义将会反应到【Java栈】的【本地变量表中】，作为一个reference类型数据出现。而new Object()这部分语义将会反应到【Java堆】中，形成一块存储了Object类型所有数据值(Instance Data,对象中各个实例字段的数据)的结构化内存。另外，在Java堆中还必须包含能查找到此对象类型数据(如对象类型、父类、实现的接口、方法等)的地址信息,这些类型数据则存储在方法区中。

		由于reference类型在Java虚拟机规范中之规定了一个指向对象的引用，并没有规定这个引用应该通过哪种方式去定位,以及访问到Java堆中的对象的具体位置,因此不同的虚拟机实现的对象访问方式会有所不同,主流方式有两种:使用句柄和直接指针。
		使用句柄访问方式：
			Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息

		使用直接指针方式：
			reference中直接存储的就是对象地址，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息

		优势：
			两种访问方式各有优势，使用句柄访问最大好处就是reference中存储的是稳定的句柄地址，在对象被移动时(GC时移动对象是非常普遍的行为)会改变句柄中的实例数据指针，而reference本身不需要被修改。使用直接指针方式的最大好处就是速度快，它节省了一次指针定位的时间开销。由于对象访问在Java中非常频繁,因此这类开销积少成多后是一项非常客观的执行成本。(hot spot使用直接指针方式进行对象访问)

	8.实战:OutOfMemoryError异常
		1.Heap(堆)
			OutOfMemoryError思路 : 只需要不断创建对象,并且保证GC Roots到对象之间有可达的路径来避免垃圾回收机制清除这些对象.

			VM args :  
			    -Xms 堆最小值
			    -Xmx 堆最大值
			    -XX:+HeadDumpOnOutOfMemoryError 让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析

			解决:
				解决这个区域的异常,一般的手段是通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转储快照进行分析,重点是确认内存中的对象是否是必要的,也就是先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。
				如果是内存泄漏,可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法回收他们的。
				如果不存在泄漏，换句话说就是内存中的对象确实都必须活着，那就应该检查虚拟机的堆参数与物理机内存对比看是否能调大。

		2.虚拟机栈和本地方法栈溢出
			VM args :
			-Xss 栈容量

			HotSpot虚拟机并不区分虚拟机栈和本地方法栈,因此对于HotSpot来说-Xoss参数(设置本地方法栈大小)虽然存在但实际上是无效的,栈容量只由-Xss(每个线程的虚拟机栈大小)参数设定。
			
			StackOverflowError : 线程请求的栈深度大于虚拟机所允许的最大深度,将抛出StackoverFlowError异常

			OutOfMemoryError : 虚拟机在扩展栈时无法申请到足够的内存空间,则抛出OutOfMemorryError异常

			这里两种异常其实是对一种事情的两种描述而已,因为当栈空间无法继续分配内存时,到底是栈深度太大,还是由于内存太小无法申请到足够内存空间,本质都是一样的

			StackOverflowError思路:
				1.可以通过创建大量变量来增加栈中的局部变量表的大小使得栈的大小无法容纳局部变量表引发StackOverflowError异常.
				2.通过大量调用方法的方式创建栈帧使得栈无法容纳大量栈帧引发StackOverflowError异常

			OutOfMemoryError思路:
				大量创建线程,使得虚拟机无法为创建线程申请到足够的内存引发异常.

			解决:
				StackOverflowError : 使用-Xss调整栈的大小
				OutOfMemoryError : 
					1.出现这个异常的原因一般是由于【创建线程过多】，可以通过调低堆、方法区的内存大小使得有更多的内存空间可以用来创建线程。
					2.使用-Xss调低栈的大小使得虚拟机可以创建更多线程


		3.运行时常量池溢出

			-XX:PermSize=128m -> 方法区的初始化内存大小
			-XX:MaxPermSize=128m -> 方法区的最大内存容量

			OutOfMemoryError : 运行时常量池无法申请内存时会抛出OutOfMemoryError

			OutOfMemoryError思路 : 使用String类的intern方法(该方法会在常量池中寻找equals的字符串,如果没有则将自己添加到常量池中)添加大量字符串到运行时常量池,造成OutOfMemoryError

			PS:实验使用-XX:PermSize与-XX:MaxPermSize均无法控制方法区最大值(虚拟机还是会继续为方法区申请内存)

		4.方法区内存溢出

			方法区用于存放Class的相关信息,如类名、访问修饰符、常量池、字段描述、方法描述等。

			OutOfMemoryError思路:通过加载大量类使得方法区内存溢出

		5.本机直接内存溢出

			DirectMemory容量可以通过=XX:MaxDirectMemorySize指定,如果不指定,则默认与Java堆的最大值(-Xmx指定)一样。

			OutOfMemoryError思路 : 使用Unsafe类的allocateMomory方法分配内存


			









