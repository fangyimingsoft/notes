一、判断对象已死
	1.引用计数法
		给对象添加一个引用计数器，每当有一个地方引用它时，计数器加1;引用失效时,计数器减1;任何时刻计数器为0的对象就是不可能再被使用的。但是它无法解决对象之间循环引用的问题。

	2.根搜索算法
		思路是通过一系列名为“GC Roots”的对象作为起始点,从这个节点开始向下搜索,搜索所有走过的路径称为引用链(Reference Chain),当一个对象到GC Roots没有任何一条引用链相连,则证明此对象不可用。
		Java中可作为GC Roots的对象包括:
		1) 虚拟机栈(栈帧中的本地变量表)中的引用的对象
		2) 方法区中的类静态属性引用的对象
		3) 方法区中的常量引用的对象
		4) 本地方法栈中JNI(即一般说的Native方法)的引用的对象
		回收策略:
		   I:对象在GC Roots上不可达,也并非是"非死不可"的,这时他们至少要经历两次标记过程才能宣告他们死亡。
		   II:在进行根搜索算法后发现没有与GC Roots相连接的引用链,那么它会被第一次标记并且进行一次筛选,筛选条件为是否有必要执行finalize方法:
		   		1.当对象没有覆盖finalize方法时
		   		2.finalize方法已经被虚拟机调用过(任何一个对象的finalize方法只会被系统调用一次)
		   III:虚拟机将这两种情况视为"没有必要执行",如果有必要执行会将这个对象放入一个名为F-Queue的队列中,并在稍后由一条虚拟机自动创建的、低优先级的Finalizer线程中执行。
		       (虚拟机不承诺等待这个线程运行结束,原因是如果一个对象的finalize方法执行缓慢或发生了异常,会导致队列中的其他对象等待)
		   IV:稍后GC将对F-Queue中的对象进行第二次小规模标记,如果对象在finalize方法中拯救自己(与引用链上的对象建立链接),那么在第二次标记时它将被移出"即将回收"的集合;
		   V:如果这个时候没有重新与引用链上的对象建立链接,对象就要被回收了

	3.回收方法区(HotSpot中的永久代 也叫非堆Non Heap)
		方法区的回收主要分为两部分:
		1.废弃的常量
			1.没有任何对象引用常量池中的对象
			2.没有其他地方引用了这个字面量
			如果满足条件并发生内存回收，有必要的话，常量会被系统“请”出常量池

		2.无用的类
			1.该类所有的实例已被回收,就是说Java堆中不存在该类的任何实例
			2.加载该类的ClassLoader已被回收
			3.该类对应的Class对象没有被任何地方引用,无法在任何地方通过反射访问该类的方法。
			满足上述3个条件的无用类，虚拟机可以对类进行回收(不是必然会回收)。

		VM args:
			-Xnoclassgc 是否对类进行回收
			-verbose:class 需配合-XX:TraceClassLoading 和 -XX:TraceClassUnLoading使用
			-XX:TraceClassLoading 查看类的加载信息(可以在Product版的虚拟机中使用)
			-XX:TraceClassUnLoading 查看类的卸载信息(可以在fastdebug版的虚拟机中使用)

二、垃圾收集算法
	1.标记-清除算法	
		思路:算法分为两个阶段,"标记"和"清除":首先标记出所有要回收的对象,在标记完成后统一回收所有被标记的对象。这是最基础的收集算法(后面的收集算法都是基于这种思路并改进实现的)

		缺点:
			1.效率问题,"标记"和"清除"的效率都不高
			2.空间间隔问题,标记清除后会产生大量不连续的内存碎片,内存碎片太多会导致分配大对象时无法找到足够的连续内存而不得不触发另外一次垃圾收集操作

	2.复制算法
		思路:将可用内存分为大小相等的两块,当其中一块用完时,将存活的对象拷贝到另外一块内存,再把已使用过的内存空间一次清除掉。
			 (现在的商业虚拟机都采用这种收集算法来回收【新生代】)

		优点：
			1.不用考虑内存碎片等复杂问题
			2.每次回收都只对其中的一块进行内存回收操作

		缺点：
			1.可用内存为原来的一半,代价过高

		HotSpot针对复制算法的改进:
			HotSpot将【新生代】分为一块较大的Eden空间和两块较小的Survivor空间，默认的大小比例是8 : 1 : 1。

			回收策略：每次回收时，将Eden和Survivor中还存活着的对象一次性地拷贝到另外一块Survivor空间上,最后清理掉Eden和刚才用过的Survivor的空间。
					 (当Survivor空间不够时,需要依赖其他内存(这里指老年代)进行分配担保(Handle Promotion))


	3.标记-整理算法
		思想:在老年代中，由于对象存活率较高，使用复制算法代价很大。"标记-整理"算法与"标记-清除"算法一样,只是后续步骤不是直接对可回收对象进行清理,而是让所有存活对象向一端移动,然后直接清理掉边界以外的内存。



	4.分代收集算法
		思想:

三、垃圾收集器

四、内存分配与回收策略
